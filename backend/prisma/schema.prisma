datasource db {
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"
}

enum Role {
  USER
  PROFESSIONAL
  ADMIN
  MODERATOR
}

enum BookingStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
}

enum NotificationType {
  BOOKING_CONFIRM
  BOOKING_REMINDER
  BOOKING_CANCEL
  PAYMENT_SUCCESS
  PAYMENT_FAILED
  DISPUTE_UPDATE
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum PaymentMethod {
  BKASH
  ROCKET
  NAGAD
}

enum OTPType {
  REGISTRATION
  PASSWORD_RESET
  MFA  // Added for future MFA extension
}

model User {
  id                   String               @id @default(cuid())
  name                 String?
  email                String               @unique
  passwordHash         String?              // Optional for social-only users
  role                 Role                 @default(USER)
  isVerified           Boolean              @default(false)
  avatar               String?              // Cloudinary URL
  bio                  String?
  phone                String?
  location             String?
  timezone             String               @default("Asia/Dhaka")
  lastLoginAt          DateTime?
  failedAttempts       Int                  @default(0)  // For lockout
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt

  accounts             Account[]
  refreshTokens        RefreshToken[]
  professionalProfile  ProfessionalProfile?
  bookedBookings       Booking[]            @relation("UserBookings")
  professionalBookings Booking[]            @relation("ProfessionalBookings")
  notifications        Notification[]
  disputes             Dispute[]            @relation("Complainant")
  resolvedDisputes     Dispute[]            @relation("ResolvedBy")
  approvedMeetings     Meeting[]            @relation("ApprovedBy")

  @@index([email])
  @@index([role])
}

model Account {
  id                 String    @id @default(cuid())
  userId             String
  provider           String    // 'google', 'facebook', 'email', etc.
  providerAccountId  String    // Provider's unique ID (or email for password auth)
  accessToken        String?   // Short-lived, optional
  refreshToken       String?   // Hashed if stored
  expiresAt          DateTime? // For access token
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  user               User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model RefreshToken {
  id         String   @id @default(cuid())
  userId     String
  tokenHash  String   // Hashed refresh token
  expiresAt  DateTime
  createdAt  DateTime @default(now())

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model OTP {
  id          String   @id @default(cuid())
  email       String
  codeHash    String 
  type        OTPType
  expiresAt   DateTime
  attempts    Int      @default(0)
  resendCount Int      @default(0) 
  createdAt   DateTime @default(now())

  tempName     String?
  tempPasswordHash String? 
  tempPhone    String?

  @@unique([email, type]) 
  @@index([email])
  @@index([expiresAt]) 
}

model ProfessionalProfile {
  id             String    @id @default(cuid())
  userId         String    @unique
  specialties    String[]
  certifications String[]  // Cloudinary URLs
  rates          Decimal
  availability   Json?     // e.g., { "slots": [...] }
  experience     Int?
  languages      String[]
  isVerified     Boolean   @default(false)  // Admin approval
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Booking {
  id                   String         @id @default(cuid())
  userId               String
  professionalId       String
  startTime            DateTime
  endTime              DateTime
  status               BookingStatus  @default(PENDING)
  notes                String?
  price                Decimal?
  cancellationReason   String?
  cancelledBy          String?
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt

  user                 User           @relation("UserBookings", fields: [userId], references: [id])
  professional         User           @relation("ProfessionalBookings", fields: [professionalId], references: [id])
  meeting              Meeting?
  review               Review?
  payment              Payment?
  dispute              Dispute?

  @@index([userId])
  @@index([professionalId])
  @@index([status])
  @@index([startTime])
  @@index([professionalId, startTime]) 
}

model Meeting {
  id                   String   @id @default(cuid())
  bookingId            String   @unique
  streamCallId         String  
  recorded             Boolean  @default(false)
  recordingUrl         String?  
  transcript           String?  
  approvedForStorage   Boolean  @default(false)  
  approvedBy           String?  
  approvedAt           DateTime?

  booking              Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  approvedByUser       User?    @relation("ApprovedBy", fields: [approvedBy], references: [id])

  @@index([bookingId])
  @@index([streamCallId])
}

model Notification {
  id       String             @id @default(cuid())
  userId   String
  type     NotificationType
  message  String
  sentAt   DateTime           @default(now())
  isRead   Boolean            @default(false)

  user     User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([sentAt])
}

model Review {
  id         String   @id @default(cuid())
  bookingId  String   @unique
  rating     Int      // 1-5
  comment    String?
  createdAt  DateTime @default(now())

  booking    Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([bookingId])
  @@index([rating])
}

model Payment {
  id               String         @id @default(cuid())
  bookingId        String         @unique
  amount           Decimal
  status           PaymentStatus  @default(PENDING)
  paymentMethod    PaymentMethod
  trxId            String?
  payerMobile      String?
  merchantInvoice  String?
  paidAt           DateTime?
  refundAmount     Decimal        @default(0)
  refundTrxId      String?
  invoiceUrl       String?        // Cloudinary PDF
  createdAt        DateTime       @default(now())

  booking          Booking        @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  logs             PaymentLog[]

  @@index([bookingId])
  @@index([status])
  @@index([paymentMethod])
}

model PaymentLog {
  id         String   @id @default(cuid())
  paymentId  String
  action     String   // 'CREATE', 'EXECUTE', etc.
  request    Json?
  response   Json?
  createdAt  DateTime @default(now())

  payment    Payment  @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([paymentId])
  @@index([createdAt])
}

model Dispute {
  id           String   @id @default(cuid())
  bookingId    String   @unique
  userId       String   // Complainant
  description  String
  status       String   @default("OPEN")  // OPEN, RESOLVED, CLOSED
  resolvedBy   String?  // Moderator/Admin ID
  resolvedAt   DateTime?

  booking      Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  user         User     @relation("Complainant", fields: [userId], references: [id])
  resolvedByUser User?  @relation("ResolvedBy", fields: [resolvedBy], references: [id])

  @@index([bookingId])
  @@index([userId])
  @@index([status])
}